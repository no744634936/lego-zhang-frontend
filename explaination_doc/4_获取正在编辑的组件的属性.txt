1， 点击某个组件按钮，添加到编辑器页面，点击编辑器内的组件，
    该组件呈现选中状态,并获取该组件的各种属性内容

    说到底就是给LText组件套上一个wrapper，
    在views/Editor.vue 文件里 使用 EditWrapper 组件包裹住LText组件

    使用EditWrapper 让逻辑跟业务分离
    像LText 这种类型的html 展示型的组件，
    里面就别写上for ，if ，点击，拖拽事件之类的逻辑了，
    在外面包裹一层wrapper 在这个wrapper里面写逻辑就好


2,  components/EditWrapper.vue 
    (这种最小的展示型的组件就不要跟store扯上关系,
    跟store有关的操作都交给父组件views/Editor.vue 来做，
    所以就会有子组件emit事件返回些数据，让父组件根据这些数据来更新store)

    设置从父组件传过来的id ，
    此时active默认为false，
    也就是将class="{ active: active }" 设置为false

    然后点击EditWrapper 触发 onItemClick 
    然后触发 onItemClick将id 回传给父组件views/Editor.vue
    父组件用setActive 接收并触发 setElementActive 方法, 
    然后触发store里的setElementActive 方法


3,  store/editor.ts

    setElementActive 方法通过获取到的id 更新 store里面的 currentElement
    点击的哪一个EditWrapper ，currentElement的值就是那个EditWrapper的id

4,  views/Editor.vue 
    store 中的currentElement 被更新后，
    就可以用getCurrentEditedElement 方法，
    根据currentElement 来取出被点击的 item的所有数据

    -- 将拿到的item数据展示在右侧<pre> 标签里面

    -- 为了美观，给选中的item添加一个边框，给 EditWrapper组件传递一个actve 属性
       什么时候false ，什么时候true 
       :active="component.id===(currentEditedElement&& currentEditedElement.id)
       
       其中 (currentEditedElement&& currentEditedElement.id) 的意思是
       当 currentEditedElement存在的时候　返回currentEditedElement.id

5， components/EditWrapper.vue 
    接收到父组件传过来的active，决定是否显示边框


